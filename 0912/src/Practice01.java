import java.util.Arrays;
/*
 * 문제: 연습문제 - 아파트 색칠 규칙
 * 난이도: 보통
 * 
 * 풀이 아이디어:
 *  - 조건에 따라 칠하는 방법 수는 피보나치 점화식과 동일하게 전개
 *    f(n) = f(n-1) + f(n-2)
 *  - 초기값.
 *    f(1) = 2 (노랑, 파랑)
 *    f(2) = 3 (YY, YB, BY)
 * 
 * 알고리즘 흐름:
 *  1. memo 배열을 -1로 초기화하여 아직 계산되지 않은 값을 표시한다.
 *  2. f(1)=2, f(2)=3 초기값을 지정한다.
 *  3. fibo(n)을 호출할 때, 
 *  memo[n]이 계산되지 않았다면
 *     fibo(n-1)+fibo(n-2)를 계산하여 저장한다.
 *     계산 되었다면
 *     memo[n] 값 반환
 *  5. f(n) 출력.
 * 
 * 시간 복잡도:
 *  - 메모이제이션 덕분에 모든 n에 대해 한 번씩만 계산하므로 O(n).
 * 공간 복잡도:
 *  - memo 배열 크기 O(n).
 */

public class Practice01 {
    static int[] memo; // DP 메모이제이션 배열

    // 탑다운 방식(재귀 + 메모이제이션) 피보나치
    static public int fibo(int n) {
        // 계산되지 않은 값이면 재귀 호출로 채운다
        if (memo[n] == -1) {
            memo[n] = fibo(n - 1) + fibo(n - 2);
        }
        // 이미 계산된 값이면 메모리에서 바로 꺼낸다
        return memo[n];
    }

    public static void main(String[] args) {
        int n = 8; // 구하고자 하는 값 (f(8))
        
        // 1) memo 배열 선언 (크기 n+1, 인덱스 0~n까지 사용)
        memo = new int[n + 1];
        
        // 2) 배열을 -1로 채워 아직 계산되지 않았음을 표시
        Arrays.fill(memo, -1);
        
        // 3) 초기조건 지정 (문제 규칙에 맞게)
        memo[1] = 2;
        memo[2] = 3;
        
        // 4) 결과 출력
        System.out.println(fibo(n)); // 👉 55
    }
}

/*
 * 왜 피보나치 형태인가?
마지막 층이 노랑이면 → 이전 모든 경우에 이어붙일 수 있음 = f(n-1)
마지막 층이 파랑이면 → 직전 층이 반드시 노랑이어야 함 = f(n-2)
→ 따라서 f(n)=f(n-1)+f(n-2)
 
 * 메모이제이션 장점
재귀를 쓰더라도 한 번 계산한 값은 다시 구하지 않음 → 중복 호출 방지.
시간복잡도 O(2^n) → O(n)으로 줄어듦.
 */
